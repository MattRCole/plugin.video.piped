# Module: main
# Author: Roman V. M.
# Created on: 28.11.2014
# License: GPL v.3 https://www.gnu.org/copyleft/gpl.html
"""
Example video plugin that is compatible with Kodi 19.x "Matrix" and above
"""
import functools
from typing import Callable, Optional, TypedDict, cast

import m3u8
from ttml2ssa import Ttml2Ssa
import requests
import sys
from urllib.parse import urlencode, parse_qsl
# import xbmc
import xbmcgui
import xbmcplugin

from piped.types import Stream, StreamResponse, StreamSubtitle


# _URL = sys.argv[0]
_HANDLE = int(sys.argv[1])

def get_subtitle_from_piped(subtitle: Optional[StreamSubtitle], stream: Stream) -> Optional[str]:
    if subtitle is None:
        return None

    response = requests.get(subtitle['url'], headers={'Accept': 'text/xml;*/*'})
    if response.status_code < 200 or response.status_code >= 300:
        return None

    try:
        ttml = Ttml2Ssa(source_fps=stream["fps"])

        ttml.parse_ttml_from_string(response.text)
        path = "/tmp/piped-subtitles.srt"
        ttml.write2file(path)
        return path  # "file:/{path}"
    except Exception:
        return None


def play_video(path):
    response = requests.get(f'https://pipedapi.kavin.rocks/streams/{path}')
    piped_response: StreamResponse = response.json()
    # import web_pdb; web_pdb.set_trace()

    playlist_of_playlists = m3u8.load(piped_response['hls'])

    class Acc(TypedDict, total=False):
        pps: int
        playlist: m3u8.Playlist

    def playlist_reducer(acc: Acc, playlist: m3u8.Playlist) -> Acc:
        stream_info = playlist.stream_info
        if stream_info is None:
            return acc

        if stream_info.resolution is None or not playlist.uri:
            return acc

        resolution: tuple[int, int] = stream_info.resolution
        frame_rate = stream_info.frame_rate if int(stream_info.frame_rate) is not None else 1

        pps = resolution[0] * resolution[1] * frame_rate

        if pps <= acc["pps"]:
            return acc

        return {"pps": pps, "playlist": playlist}

    [protocol, _, domain, *__] = piped_response['hls'].split('/')

    base_url = f"{protocol}//{domain}"

    playlist_of_playlists
    playlist_to_grab = functools.reduce(playlist_reducer, list(playlist_of_playlists.playlists), {"pps": 0})["playlist"]
    main_playlist = m3u8.M3U8(
        base_path=base_url,
    )

    audio_to_grab: str = playlist_to_grab.stream_info.audio

    playlist_to_grab.base_path = f"{base_url}/{playlist_to_grab.base_path}"
    main_playlist.add_playlist(playlist_to_grab)
    for m in playlist_of_playlists.media:
        media = cast(m3u8.Media, m)
        if media.group_id == audio_to_grab:
            media.base_path = f"{base_url}/{media.base_path}"
            main_playlist.add_media(media)

    main_playlist.is_independent_segments = True
    main_playlist.data["is_independent_segments"] = True
    playlist_path = "/tmp/piped.m3u8"
    main_playlist.dump(playlist_path)


    # hls_url = f"{protocol}//{domain}/{playlist_to_grab['uri'].removeprefix('/')}"


    subtitle = next(
        (subtitle for subtitle in piped_response['subtitles'] if 'en' in subtitle['code'] and subtitle['autoGenerated'] is False),
        None
    )

    list_item = xbmcgui.ListItem(
        label=piped_response["title"],
        label2=piped_response["uploader"],
        # path=hls_url,
        # path=piped_response["hls"],
        path=playlist_path
    )
    list_item.setMimeType('application/x-mpegURL')
    list_item.setContentLookup(False)
    list_item.setProperty("inputstream", "inputstream.ffmpegdirect")
    list_item.setProperty("inputstream.ffmpegdirect.is_realtime_stream", "false")
    # list_item.setProperty("inputstream.ffmpegdirect.stream_mode", "timeshift")
    # list_item.setProperty("inputstream.ffmpegdirect.stream_mode", "catchup")
    list_item.setProperty("inputstream.ffmpegdirect.manifest_type", "hls")
    list_item.setProperty("inputstream.ffmpegdirect.open_mode", "ffmpeg")
    # list_item.setProperty("inputstream.ffmpegdirect.playback_as_live", "true")
    # list_item.setProperty(
    #     "inputstream.ffmpegdirect.default_programme_duration",
    #     str(piped_response["duration"]),
    # )

    # list_item.setProperty('inputstream', 'inputstream.ffmpegdirect')
    # list_item.setProperty('inputstream.adaptive.manifest_type', 'hls')

    subtitle_path = get_subtitle_from_piped(subtitle, piped_response['videoStreams'][0])
    if subtitle_path is not None:
        list_item.setSubtitles([subtitle_path])

    # list_item.setArt({
    #     "thumb": piped_response["thumbnailUrl"]
    # })

    xbmcplugin.setResolvedUrl(handle=_HANDLE, succeeded=True, listitem=list_item)


def router(paramstring, action = None):
    """
    Router function that calls other functions
    depending on the provided paramstring

    :param paramstring: URL encoded plugin paramstring
    :type paramstring: str
    """
    params = dict(parse_qsl(paramstring))
    if action:
        if action == 'play':
            # Play a video from a provided URL.
            play_video(params['video_id'])
        else:
            raise ValueError('Invalid paramstring: {}!'.format(paramstring))
    # else:
    #     list_categories()


if __name__ == '__main__':
    # Call the router function and pass the plugin call parameters to it.
    # We use string slicing to trim the leading '?' from the plugin call paramstring
    # import web_pdb; web_pdb.set_trace()
    [*_, action] = [segment for segment in sys.argv[0].split('/') if segment != '']
    # args = [arg for arg in sys.argv]
    router(sys.argv[2][1:], action)
