# Module: main
# Author: Roman V. M.
# Created on: 28.11.2014
# License: GPL v.3 https://www.gnu.org/copyleft/gpl.html
"""
Example video plugin that is compatible with Kodi 19.x "Matrix" and above
"""
import functools
from typing import Callable, List, Optional, TypedDict, cast

import m3u8
import m3u8.mixins
from ttml2ssa import Ttml2Ssa
import requests
import sys
import os
import shutil
from urllib.parse import urlencode, parse_qsl
import xbmc
import xbmcgui
import xbmcvfs
import xbmcplugin

from piped.types import Stream, StreamResponse, StreamSubtitle


# _URL = sys.argv[0]
_HANDLE = int(sys.argv[1])

def get_subtitle_from_piped(subtitle: Optional[StreamSubtitle], stream: Stream) -> Optional[str]:
    if subtitle is None:
        return None

    response = requests.get(subtitle['url'], headers={'Accept': 'text/xml;*/*'})
    if response.status_code < 200 or response.status_code >= 300:
        return None

    try:
        ttml = Ttml2Ssa(source_fps=stream["fps"])

        ttml.parse_ttml_from_string(response.text)
        path = "/tmp/piped-subtitles.srt"
        ttml.write2file(path)
        return path  # "file:/{path}"
    except Exception:
        return None


def get_playlist_ready(
        playlist_ref: m3u8.mixins.BasePathMixin,
        base_url: str,
        hls_path: str,
        base_dir,
):
    """
    Downloads and saves the m3u8 playlist, updating all segments to have absolute urls, also updates the resources
    uri to point to the downloaded file
    
    Mutates playlist_ref!
    """

    # import web_pdb; web_pdb.set_trace()
    # resolved_url = playlist_ref.absolute_uri if playlist_ref.absolute_uri[:4] == 'http' else f"{base_url}/{playlist_ref.absolute_uri}"
    resolved_url = f"{base_url}/{playlist_ref.uri}"

    playlist = m3u8.load(resolved_url)

    for s in playlist.segments:
        segment = cast(m3u8.Segment, s)
        segment.base_path = f"{base_url}{segment.base_path}"
    
    with open(f"{base_dir}/{hls_path}", "w") as file:
        file.write(
            playlist.dumps().replace('URI="/', f'URI="{base_url}/')
        )

    # ordering matters here apparently, also these 3 are all necessary
    playlist_ref.uri = hls_path
    playlist_ref.base_path = ''
    playlist_ref.uri = hls_path

    return hls_path


def play_video(path):
    response = requests.get(f'https://pipedapi.kavin.rocks/streams/{path}')
    piped_response: StreamResponse = response.json()
    # import web_pdb; web_pdb.set_trace()

    master_playlist = m3u8.load(piped_response['hls'])

    class Acc(TypedDict, total=False):
        res_0: int
        fps: int
        playlist: m3u8.Playlist
        bandwidth: int

    def playlist_reducer(acc: Acc, playlist: m3u8.Playlist) -> Acc:
        stream_info = playlist.stream_info
        if stream_info is None:
            return acc

        if stream_info.resolution is None or not playlist.uri:
            return acc

        resolution: tuple[int, int] = stream_info.resolution
        frame_rate = stream_info.frame_rate if int(stream_info.frame_rate) is not None else 1

        if resolution[0] > 1920 or resolution[0] < acc["res_0"]:
            return acc

        if frame_rate < acc["fps"]:
            return acc

        if stream_info.bandwidth < acc["bandwidth"]:
            return acc

        return {"fps": frame_rate, "res_0": resolution[0], "playlist": playlist, "bandwidth": stream_info.bandwidth}

    [protocol, _, domain, *__] = piped_response['hls'].split('/')

    base_url = f"{protocol}//{domain}"
    base_dir = "/tmp/piped/hls-manifests"
    shutil.rmtree(base_dir, ignore_errors=True)
    os.makedirs(base_dir)

    video_playlist = functools.reduce(playlist_reducer, list(master_playlist.playlists), {"res_0": 0, "fps": 0, "bandwidth": 0})["playlist"]
    new_master_playlist = m3u8.M3U8()

    audio_id: str = video_playlist.stream_info.audio

    # import web_pdb; web_pdb.set_trace()

    audio_playlists: List[m3u8.Media] = [m for m in master_playlist.media if m.group_id == audio_id and 'en' in (m.language or 'en')]

    get_playlist_ready(video_playlist, base_url=base_url, base_dir=base_dir, hls_path="video-index.m3u8")
    video_playlist.stream_info.subtitles = 'NONE'
    for audio_playlist in audio_playlists:
        audio_path = xbmcvfs.makeLegalFilename(f"{audio_playlist.language}-audio-index.m3u8").lstrip('/').rstrip('/')
        get_playlist_ready(audio_playlist, base_url=base_url, base_dir=base_dir, hls_path=audio_path)
        audio_playlist

    new_master_playlist.add_playlist(video_playlist)
    new_master_playlist.add_media(audio_playlist)

    new_master_playlist.is_independent_segments = True
    new_master_playlist.data["is_independent_segments"] = True
    hls_path = f"{base_dir}/index.m3u8"
    new_master_playlist.dump(hls_path)

    subtitle = next(
        (subtitle for subtitle in piped_response['subtitles'] if 'en' in subtitle['code'] and subtitle['autoGenerated'] is False),
        None
    )

    list_item = xbmcgui.ListItem(
        label=piped_response["title"],
        label2=piped_response["uploader"],
        path=hls_path,
    )
    list_item.setMimeType('application/x-mpegURL')
    list_item.setContentLookup(False)
    list_item.setProperty("inputstream", "inputstream.ffmpegdirect")
    list_item.setProperty("inputstream.ffmpegdirect.is_realtime_stream", "false")
    list_item.setProperty("inputstream.ffmpegdirect.manifest_type", "hls")
    list_item.setProperty("inputstream.ffmpegdirect.open_mode", "ffmpeg")

    subtitle_path = get_subtitle_from_piped(subtitle, piped_response['videoStreams'][0])
    if subtitle_path is not None:
        list_item.setSubtitles([subtitle_path])

    list_item.setArt({
        "thumb": piped_response["thumbnailUrl"]
    })

    xbmcplugin.setResolvedUrl(handle=_HANDLE, succeeded=True, listitem=list_item)


def router(paramstring, action = None):
    """
    Router function that calls other functions
    depending on the provided paramstring

    :param paramstring: URL encoded plugin paramstring
    :type paramstring: str
    """
    params = dict(parse_qsl(paramstring))
    if action:
        if action == 'play':
            # Play a video from a provided URL.
            play_video(params['video_id'])
        else:
            raise ValueError('Invalid paramstring: {}!'.format(paramstring))
    # else:
    #     list_categories()


if __name__ == '__main__':
    # Call the router function and pass the plugin call parameters to it.
    # We use string slicing to trim the leading '?' from the plugin call paramstring
    # import web_pdb; web_pdb.set_trace()
    [*_, action] = [segment for segment in sys.argv[0].split('/') if segment != '']
    # args = [arg for arg in sys.argv]
    router(sys.argv[2][1:], action)
